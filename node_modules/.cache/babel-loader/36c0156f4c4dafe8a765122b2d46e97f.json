{"ast":null,"code":"function diff(oldTree, newTree) {\n  // 声明变量patches用来存放补丁的对象\n  var patches = {}; // 第一次比较应该是树的第0个索引\n\n  var index = 0; // 递归树 比较后的结果放到补丁里\n\n  walk(oldTree, newTree, index, patches);\n  return patches;\n}\n\nfunction walk(oldNode, newNode, index, patches) {\n  // 每个元素都有一个补丁\n  var current = [];\n\n  if (!newNode) {\n    // rule1\n    current.push({\n      type: 'REMOVE',\n      index: index\n    });\n  } else if (isString(oldNode) && isString(newNode)) {\n    // 判断文本是否一致\n    if (oldNode !== newNode) {\n      current.push({\n        type: 'TEXT',\n        text: newNode\n      });\n    }\n  } else if (oldNode.type === newNode.type) {\n    // 比较属性是否有更改\n    var attr = diffAttr(oldNode.props, newNode.props);\n\n    if (Object.keys(attr).length > 0) {\n      current.push({\n        type: 'ATTR',\n        attr: attr\n      });\n    } // 如果有子节点，遍历子节点\n\n\n    diffChildren(oldNode.children, newNode.children, patches);\n  } else {\n    // 说明节点被替换了\n    current.push({\n      type: 'REPLACE',\n      newNode: newNode\n    });\n  } // 当前元素确实有补丁存在\n\n\n  if (current.length) {\n    // 将元素和补丁对应起来，放到大补丁包中\n    patches[index] = current;\n  }\n}\n\nfunction isString(obj) {\n  return typeof obj === 'string';\n}\n\nfunction diffAttr(oldAttrs, newAttrs) {\n  var patch = {}; // 判断老的属性中和新的属性的关系\n\n  for (var key in oldAttrs) {\n    if (oldAttrs[key] !== newAttrs[key]) {\n      patch[key] = newAttrs[key]; // 有可能还是undefined\n    }\n  }\n\n  for (var _key in newAttrs) {\n    // 老节点没有新节点的属性\n    if (!oldAttrs.hasOwnProperty(_key)) {\n      patch[_key] = newAttrs[_key];\n    }\n  }\n\n  return patch;\n} // 所有都基于一个序号来实现\n\n\nvar num = 0;\n\nfunction diffChildren(oldChildren, newChildren, patches) {\n  // 比较老的第一个和新的第一个\n  oldChildren.forEach(function (child, index) {\n    walk(child, newChildren[index], ++num, patches);\n  });\n} // 默认导出\n\n\nexport default diff;","map":{"version":3,"sources":["/Users/xs/technology-research/VirtualDom/src/Diff.js"],"names":["diff","oldTree","newTree","patches","index","walk","oldNode","newNode","current","push","type","isString","text","attr","diffAttr","props","Object","keys","length","diffChildren","children","obj","oldAttrs","newAttrs","patch","key","hasOwnProperty","num","oldChildren","newChildren","forEach","child"],"mappings":"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","sourcesContent":["function diff(oldTree, newTree) {\n  // 声明变量patches用来存放补丁的对象\n  let patches = {};\n  // 第一次比较应该是树的第0个索引\n  let index = 0;\n  // 递归树 比较后的结果放到补丁里\n  walk(oldTree, newTree, index, patches);\n\n  return patches;\n}\n\nfunction walk(oldNode, newNode, index, patches) {\n  // 每个元素都有一个补丁\n  let current = [];\n\n  if (!newNode) { // rule1\n      current.push({ type: 'REMOVE', index });\n  } else if (isString(oldNode) && isString(newNode)) {\n      // 判断文本是否一致\n      if (oldNode !== newNode) {\n          current.push({ type: 'TEXT', text: newNode });\n      }\n\n  } else if (oldNode.type === newNode.type) {\n      // 比较属性是否有更改\n      let attr = diffAttr(oldNode.props, newNode.props);\n      if (Object.keys(attr).length > 0) {\n          current.push({ type: 'ATTR', attr });\n      }\n      // 如果有子节点，遍历子节点\n      diffChildren(oldNode.children, newNode.children, patches);\n  } else {    // 说明节点被替换了\n      current.push({ type: 'REPLACE', newNode});\n  }\n  \n  // 当前元素确实有补丁存在\n  if (current.length) {\n      // 将元素和补丁对应起来，放到大补丁包中\n      patches[index] = current;\n  }\n}\n\nfunction isString(obj) {\n  return typeof obj === 'string';\n}\n\nfunction diffAttr(oldAttrs, newAttrs) {\n  let patch = {};\n  // 判断老的属性中和新的属性的关系\n  for (let key in oldAttrs) {\n      if (oldAttrs[key] !== newAttrs[key]) {\n          patch[key] = newAttrs[key]; // 有可能还是undefined\n      }\n  }\n\n  for (let key in newAttrs) {\n      // 老节点没有新节点的属性\n      if (!oldAttrs.hasOwnProperty(key)) {\n          patch[key] = newAttrs[key];\n      }\n  }\n  return patch;\n}\n\n// 所有都基于一个序号来实现\nlet num = 0;\n\nfunction diffChildren(oldChildren, newChildren, patches) {\n  // 比较老的第一个和新的第一个\n  oldChildren.forEach((child, index) => {\n      walk(child, newChildren[index], ++num, patches);\n  });\n}\n\n// 默认导出\nexport default diff;\n"]},"metadata":{},"sourceType":"module"}